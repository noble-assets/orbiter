syntax = "proto3";

package noble.orbiter.core.v1;

import "cosmos_proto/cosmos.proto";
import "gogoproto/gogo.proto";
import "google/protobuf/any.proto";
import "noble/orbiter/core/v1/id.proto";

option go_package = "github.com/noble-assets/orbiter/types/core";

// Action represents a pre-processing step to be executed on a transfer
// before routing to the destination counterparty.
//
// Actions contain an ID that specifies the type of action and attributes
// that provide action-specific configuration. The attributes field uses
// the Any type to allow for different action implementations while
// maintaining type safety through interface constraints.
message Action {
  // This option is set to avoid the getters generation. This is a security
  // decision since GetAttributes must be called after unpacking the
  // interface.
  option (gogoproto.goproto_getters) = false;

  // id specifies the type of action to be performed.
  // This determines how the attributes field should be interpreted.
  noble.orbiter.core.v1.ActionID id = 1;

  // attributes contains the action-specific configuration data.
  // The actual type depends on the action ID and must implement
  // the `ActionAttributes` interface.
  google.protobuf.Any attributes = 2 [(cosmos_proto.accepts_interface) = "noble.orbiter.v1.ActionAttributes"];
}

// Forwarding contains the information for a cross-chain forwarding.
message Forwarding {
  // This option is set to avoid the risk to call GetAttributes
  // in the code since it has to be called after unpacking the
  // interface.
  option (gogoproto.goproto_getters) = false;

  // protocol_id specifies the bridging protocol type to use
  // to route incoming funds to a destination chain.
  noble.orbiter.core.v1.ProtocolID protocol_id = 1;

  // attributes contains protocol-specific configuration data.
  // The actual type depends on the protocol ID and must implement
  // the `ForwardingAttributes` interface.
  google.protobuf.Any attributes = 2 [(cosmos_proto.accepts_interface) = "noble.orbiter.v1.ForwardingAttributes"];

  // passthrough_payload allows to pass additional metadata
  // to the destination chain. This field is not interpreted by
  // the orbiter module.
  bytes passthrough_payload = 3;
}

// Payload represents the data the orbiter module
// requires to handle cross-chain packets.
message Payload {
  // pre_actions are a list of actions the orbiter module can interpret
  // and executes before completing the cross-chain routing.
  repeated Action pre_actions = 1;

  // forwarding contains the required information to complete a cross-chain
  // routing through an orbiter-supported protocol.
  Forwarding forwarding = 2;
}

// PayloadWrapper defines the expected JSON structure the module expect when receiving
// the payload from protocols encoding metadata as string. This wrapper is used to
// easily identify if the metadata containing the payload is correctly defined.
message PayloadWrapper {
  // orbiter represents the orbiter payload containing cross-chain
  // routing info and possibly pre routing actions.
  Payload orbiter = 1;
}

// PendingPayload holds the information that goes into the stored payload hash.
message PendingPayload {
  // The sequence number of the pending payload.
  uint64 sequence = 1;
  // The submitted payload that will be registered as pending.
  Payload payload = 2;
  // The block time of inclusion of the payload in nanoseconds.
  int64 timestamp = 3;
}
