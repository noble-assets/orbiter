// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/orbiter/core/v1/id.proto

package core

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ActionID identifies the type of action to be performed on a transfer.
//
// buf:lint:ignore ENUM_VALUE_PREFIX
type ActionID int32

const (
	// ACTION_UNSUPPORTED represents an unknown or unsupported action type.
	// This is the default zero value and should not be used in production.
	ACTION_UNSUPPORTED ActionID = 0
	// ACTION_FEE represents a fee collection action.
	ACTION_FEE ActionID = 1
	// ACTION_SWAP represents a token swap action.
	ACTION_SWAP ActionID = 2
)

var ActionID_name = map[int32]string{
	0: "ACTION_UNSUPPORTED",
	1: "ACTION_FEE",
	2: "ACTION_SWAP",
}

var ActionID_value = map[string]int32{
	"ACTION_UNSUPPORTED": 0,
	"ACTION_FEE":         1,
	"ACTION_SWAP":        2,
}

func (x ActionID) String() string {
	return proto.EnumName(ActionID_name, int32(x))
}

func (ActionID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_02f991dccbb42578, []int{0}
}

// ProtocolID represents the cross-chain communication protocols supported by the orbiter.
//
// buf:lint:ignore ENUM_VALUE_PREFIX
type ProtocolID int32

const (
	// PROTOCOL_UNSUPPORTED represents an unknown or unsupported protocol type.
	// This is the default zero value and should not be used in production.
	PROTOCOL_UNSUPPORTED ProtocolID = 0
	// PROTOCOL_IBC represents the Inter-Blockchain Communication protocol identifier.
	PROTOCOL_IBC ProtocolID = 1
	// PROTOCOL_CCTP represents the Cross-Chain Transmission Protocol identifier.
	PROTOCOL_CCTP ProtocolID = 2
	// PROTOCOL_HYPERLANE represents the Hyperlane protocol identifier.
	PROTOCOL_HYPERLANE ProtocolID = 3
)

var ProtocolID_name = map[int32]string{
	0: "PROTOCOL_UNSUPPORTED",
	1: "PROTOCOL_IBC",
	2: "PROTOCOL_CCTP",
	3: "PROTOCOL_HYPERLANE",
}

var ProtocolID_value = map[string]int32{
	"PROTOCOL_UNSUPPORTED": 0,
	"PROTOCOL_IBC":         1,
	"PROTOCOL_CCTP":        2,
	"PROTOCOL_HYPERLANE":   3,
}

func (x ProtocolID) String() string {
	return proto.EnumName(ProtocolID_name, int32(x))
}

func (ProtocolID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_02f991dccbb42578, []int{1}
}

// CrossChainID is an internal type used to uniquely
// identify a source or a destination of a cross-chain
// transfer and the bridge protocol used.
type CrossChainID struct {
	ProtocolId ProtocolID `protobuf:"varint,1,opt,name=protocol_id,json=protocolId,proto3,enum=noble.orbiter.core.v1.ProtocolID" json:"protocol_id,omitempty"`
	// Protocol specific identifier of a counterparty.
	CounterpartyId string `protobuf:"bytes,2,opt,name=counterparty_id,json=counterpartyId,proto3" json:"counterparty_id,omitempty"`
}

func (m *CrossChainID) Reset()      { *m = CrossChainID{} }
func (*CrossChainID) ProtoMessage() {}
func (*CrossChainID) Descriptor() ([]byte, []int) {
	return fileDescriptor_02f991dccbb42578, []int{0}
}
func (m *CrossChainID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainID.Merge(m, src)
}
func (m *CrossChainID) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainID) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainID.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainID proto.InternalMessageInfo

func (m *CrossChainID) GetProtocolId() ProtocolID {
	if m != nil {
		return m.ProtocolId
	}
	return PROTOCOL_UNSUPPORTED
}

func (m *CrossChainID) GetCounterpartyId() string {
	if m != nil {
		return m.CounterpartyId
	}
	return ""
}

func init() {
	proto.RegisterEnum("noble.orbiter.core.v1.ActionID", ActionID_name, ActionID_value)
	proto.RegisterEnum("noble.orbiter.core.v1.ProtocolID", ProtocolID_name, ProtocolID_value)
	proto.RegisterType((*CrossChainID)(nil), "noble.orbiter.core.v1.CrossChainID")
}

func init() { proto.RegisterFile("noble/orbiter/core/v1/id.proto", fileDescriptor_02f991dccbb42578) }

var fileDescriptor_02f991dccbb42578 = []byte{
	// 340 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0xcb, 0xcb, 0x4f, 0xca,
	0x49, 0xd5, 0xcf, 0x2f, 0x4a, 0xca, 0x2c, 0x49, 0x2d, 0xd2, 0x4f, 0xce, 0x2f, 0x4a, 0xd5, 0x2f,
	0x33, 0xd4, 0xcf, 0x4c, 0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x12, 0x05, 0xcb, 0xeb, 0x41,
	0xe5, 0xf5, 0x40, 0xf2, 0x7a, 0x65, 0x86, 0x52, 0x22, 0xe9, 0xf9, 0xe9, 0xf9, 0x60, 0x15, 0xfa,
	0x20, 0x16, 0x44, 0xb1, 0x52, 0x23, 0x23, 0x17, 0x8f, 0x73, 0x51, 0x7e, 0x71, 0xb1, 0x73, 0x46,
	0x62, 0x66, 0x9e, 0xa7, 0x8b, 0x90, 0x13, 0x17, 0x37, 0x58, 0x26, 0x39, 0x3f, 0x27, 0x3e, 0x33,
	0x45, 0x82, 0x51, 0x81, 0x51, 0x83, 0xcf, 0x48, 0x51, 0x0f, 0xab, 0x99, 0x7a, 0x01, 0x50, 0x95,
	0x9e, 0x2e, 0x41, 0x5c, 0x30, 0x5d, 0x9e, 0x29, 0x42, 0xea, 0x5c, 0xfc, 0xc9, 0xf9, 0xa5, 0x79,
	0x25, 0xa9, 0x45, 0x05, 0x89, 0x45, 0x25, 0x95, 0x20, 0x73, 0x98, 0x14, 0x18, 0x35, 0x38, 0x83,
	0xf8, 0x90, 0x85, 0x3d, 0x53, 0xac, 0x58, 0x66, 0x2c, 0x90, 0x67, 0xd0, 0xf2, 0xe4, 0xe2, 0x70,
	0x4c, 0x2e, 0xc9, 0xcc, 0x07, 0x59, 0x2f, 0xc6, 0x25, 0xe4, 0xe8, 0x1c, 0xe2, 0xe9, 0xef, 0x17,
	0x1f, 0xea, 0x17, 0x1c, 0x1a, 0x10, 0xe0, 0x1f, 0x14, 0xe2, 0xea, 0x22, 0xc0, 0x20, 0xc4, 0xc7,
	0xc5, 0x05, 0x15, 0x77, 0x73, 0x75, 0x15, 0x60, 0x14, 0xe2, 0xe7, 0xe2, 0x86, 0xf2, 0x83, 0xc3,
	0x1d, 0x03, 0x04, 0x98, 0xa4, 0x58, 0x3a, 0x16, 0xcb, 0x31, 0x68, 0x65, 0x72, 0x71, 0x21, 0xdc,
	0x24, 0x24, 0xc1, 0x25, 0x12, 0x10, 0xe4, 0x1f, 0xe2, 0xef, 0xec, 0xef, 0x83, 0x66, 0x9c, 0x00,
	0x17, 0x0f, 0x5c, 0xc6, 0xd3, 0xc9, 0x59, 0x80, 0x51, 0x48, 0x90, 0x8b, 0x17, 0x2e, 0xe2, 0xec,
	0x1c, 0x12, 0x20, 0xc0, 0x04, 0x72, 0x0b, 0x5c, 0xc8, 0x23, 0x32, 0xc0, 0x35, 0xc8, 0xc7, 0xd1,
	0xcf, 0x55, 0x80, 0x19, 0x62, 0x95, 0x93, 0xc1, 0x89, 0x47, 0x72, 0x8c, 0x17, 0x1e, 0xc9, 0x31,
	0x3e, 0x78, 0x24, 0xc7, 0x38, 0xe1, 0xb1, 0x1c, 0xc3, 0x85, 0xc7, 0x72, 0x0c, 0x37, 0x1e, 0xcb,
	0x31, 0x44, 0x89, 0xc1, 0x82, 0x29, 0x25, 0xb5, 0x4c, 0xbf, 0xa4, 0xb2, 0x20, 0xb5, 0x18, 0x1c,
	0x49, 0x49, 0x6c, 0xe0, 0x20, 0x32, 0x06, 0x04, 0x00, 0x00, 0xff, 0xff, 0xfa, 0x1d, 0x06, 0x6b,
	0xc1, 0x01, 0x00, 0x00,
}

func (m *CrossChainID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CounterpartyId) > 0 {
		i -= len(m.CounterpartyId)
		copy(dAtA[i:], m.CounterpartyId)
		i = encodeVarintId(dAtA, i, uint64(len(m.CounterpartyId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProtocolId != 0 {
		i = encodeVarintId(dAtA, i, uint64(m.ProtocolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintId(dAtA []byte, offset int, v uint64) int {
	offset -= sovId(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CrossChainID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProtocolId != 0 {
		n += 1 + sovId(uint64(m.ProtocolId))
	}
	l = len(m.CounterpartyId)
	if l > 0 {
		n += 1 + l + sovId(uint64(l))
	}
	return n
}

func sovId(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozId(x uint64) (n int) {
	return sovId(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CrossChainID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowId
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolId", wireType)
			}
			m.ProtocolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowId
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolId |= ProtocolID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowId
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthId
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthId
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipId(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthId
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipId(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowId
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowId
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowId
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthId
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupId
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthId
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthId        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowId          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupId = fmt.Errorf("proto: unexpected end of group")
)
